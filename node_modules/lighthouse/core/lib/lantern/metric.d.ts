export type Node = import('./base-node.js').Node;
export type NetworkNode = import('./network-node.js').NetworkNode;
export type Simulator = import('./simulator/simulator.js').Simulator;
export type Extras = {
    optimistic: boolean;
    fcpResult?: LH.Artifacts.LanternMetric | undefined;
    fmpResult?: LH.Artifacts.LanternMetric | undefined;
    interactiveResult?: LH.Artifacts.LanternMetric | undefined;
    speedline?: {
        speedIndex: number;
    } | undefined;
};
/** @typedef {import('./base-node.js').Node} Node */
/** @typedef {import('./network-node.js').NetworkNode} NetworkNode */
/** @typedef {import('./simulator/simulator.js').Simulator} Simulator */
/**
 * @typedef Extras
 * @property {boolean} optimistic
 * @property {LH.Artifacts.LanternMetric=} fcpResult
 * @property {LH.Artifacts.LanternMetric=} fmpResult
 * @property {LH.Artifacts.LanternMetric=} interactiveResult
 * @property {{speedIndex: number}=} speedline
 */
export class Metric {
    /**
     * @param {Node} dependencyGraph
     * @param {function(NetworkNode):boolean=} treatNodeAsRenderBlocking
     * @return {Set<string>}
     */
    static getScriptUrls(dependencyGraph: Node, treatNodeAsRenderBlocking?: ((arg0: NetworkNode) => boolean) | undefined): Set<string>;
    /**
     * @return {Lantern.Simulation.MetricCoefficients}
     */
    static get COEFFICIENTS(): Lantern.Simulation.MetricCoefficients;
    /**
     * Returns the coefficients, scaled by the throttling settings if needed by the metric.
     * Some lantern metrics (speed-index) use components in their estimate that are not
     * from the simulator. In this case, we need to adjust the coefficients as the target throttling
     * settings change.
     *
     * @param {number} rttMs
     * @return {Lantern.Simulation.MetricCoefficients}
     */
    static getScaledCoefficients(rttMs: number): Lantern.Simulation.MetricCoefficients;
    /**
     * @param {Node} dependencyGraph
     * @param {LH.Artifacts.ProcessedNavigation} processedNavigation
     * @return {Node}
     */
    static getOptimisticGraph(dependencyGraph: Node, processedNavigation: LH.Artifacts.ProcessedNavigation): Node;
    /**
     * @param {Node} dependencyGraph
     * @param {LH.Artifacts.ProcessedNavigation} processedNavigation
     * @return {Node}
     */
    static getPessimisticGraph(dependencyGraph: Node, processedNavigation: LH.Artifacts.ProcessedNavigation): Node;
    /**
     * @param {Lantern.Simulation.Result} simulationResult
     * @param {Extras} extras
     * @return {Lantern.Simulation.Result}
     */
    static getEstimateFromSimulation(simulationResult: Lantern.Simulation.Result, extras: Extras): Lantern.Simulation.Result;
    /**
     * @param {Lantern.Simulation.MetricComputationDataInput} data
     * @param {Omit<Extras, 'optimistic'>=} extras
     * @return {Promise<LH.Artifacts.LanternMetric>}
     */
    static compute(data: Lantern.Simulation.MetricComputationDataInput, extras?: Omit<Extras, 'optimistic'> | undefined): Promise<LH.Artifacts.LanternMetric>;
}
import * as Lantern from './types/lantern.js';
//# sourceMappingURL=metric.d.ts.map
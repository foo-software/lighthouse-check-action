{"version":3,"file":"eventbuilder.js","sourceRoot":"","sources":["../src/eventbuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import { getCurrentHub } from '@sentry/hub';\nimport { Event, EventHint, Mechanism, Options, Severity } from '@sentry/types';\nimport {\n  addExceptionMechanism,\n  addExceptionTypeValue,\n  extractExceptionKeysForMessage,\n  isError,\n  isPlainObject,\n  normalizeToSize,\n  SyncPromise,\n} from '@sentry/utils';\n\nimport { extractStackFromError, parseError, parseStack, prepareFramesForEvent } from './parsers';\n\n/**\n * Builds and Event from a Exception\n * @hidden\n */\nexport function eventFromException(options: Options, exception: unknown, hint?: EventHint): PromiseLike<Event> {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let ex: any = exception;\n  const providedMechanism: Mechanism | undefined =\n    hint && hint.data && (hint.data as { mechanism: Mechanism }).mechanism;\n  const mechanism: Mechanism = providedMechanism || {\n    handled: true,\n    type: 'generic',\n  };\n\n  if (!isError(exception)) {\n    if (isPlainObject(exception)) {\n      // This will allow us to group events based on top-level keys\n      // which is much better than creating new group when any key/value change\n      const message = `Non-Error exception captured with keys: ${extractExceptionKeysForMessage(exception)}`;\n\n      getCurrentHub().configureScope(scope => {\n        scope.setExtra('__serialized__', normalizeToSize(exception as Record<string, unknown>));\n      });\n\n      ex = (hint && hint.syntheticException) || new Error(message);\n      (ex as Error).message = message;\n    } else {\n      // This handles when someone does: `throw \"something awesome\";`\n      // We use synthesized Error here so we can extract a (rough) stack trace.\n      ex = (hint && hint.syntheticException) || new Error(exception as string);\n      (ex as Error).message = exception as string;\n    }\n    mechanism.synthetic = true;\n  }\n\n  return new SyncPromise<Event>((resolve, reject) =>\n    parseError(ex as Error, options)\n      .then(event => {\n        addExceptionTypeValue(event, undefined, undefined);\n        addExceptionMechanism(event, mechanism);\n\n        resolve({\n          ...event,\n          event_id: hint && hint.event_id,\n        });\n      })\n      .then(null, reject),\n  );\n}\n\n/**\n * Builds and Event from a Message\n * @hidden\n */\nexport function eventFromMessage(\n  options: Options,\n  message: string,\n  level: Severity = Severity.Info,\n  hint?: EventHint,\n): PromiseLike<Event> {\n  const event: Event = {\n    event_id: hint && hint.event_id,\n    level,\n    message,\n  };\n\n  return new SyncPromise<Event>(resolve => {\n    if (options.attachStacktrace && hint && hint.syntheticException) {\n      const stack = hint.syntheticException ? extractStackFromError(hint.syntheticException) : [];\n      void parseStack(stack, options)\n        .then(frames => {\n          event.stacktrace = {\n            frames: prepareFramesForEvent(frames),\n          };\n          resolve(event);\n        })\n        .then(null, () => {\n          resolve(event);\n        });\n    } else {\n      resolve(event);\n    }\n  });\n}\n"]}
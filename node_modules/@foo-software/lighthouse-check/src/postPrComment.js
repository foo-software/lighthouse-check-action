import fetch from './fetch';
import getLighthouseScoreColor from './helpers/getLighthouseScoreColor';
import lighthouseAuditTitles from './lighthouseAuditTitles';
import LighthouseCheckError from './LighthouseCheckError';
import { ERROR_UNEXPECTED_RESPONSE } from './errorCodes';
import { NAME } from './constants';

const getBadge = ({ title, score }) =>
  `![](https://img.shields.io/badge/${title}-${score}-${getLighthouseScoreColor(
    {
      isHex: false,
      score
    }
  )}?style=flat-square) `;

export default async ({
  isGitHubAction,
  isLocalAudit,
  isOrb,
  prCommentAccessToken,
  prCommentSaveOld,
  prCommentUrl,
  results,
  verbose
}) => {
  try {
    let markdown = '';

    results.forEach(result => {
      // badges
      Object.keys(result.scores).forEach(current => {
        markdown += getBadge({
          title: lighthouseAuditTitles[current].replace(/ /g, '%20'),
          score: result.scores[current]
        });
      });

      // table header
      markdown += `\n| Device ${!result.report ? '' : `| Report `}| URL |\n`;
      markdown += `|--${!result.report ? '' : `|--`}|--|\n`;

      // the emulatedformfactor
      markdown += `| ${result.emulatedFormFactor} `;

      // if we have a URL for the full report
      if (result.report) {
        markdown += `| [report](${result.report}) `;
      }

      // the url
      markdown += `| ${result.url} |\n\n`;
    });

    markdown += 'Not what you expected? Are your scores flaky? ';
    markdown += `[Run Lighthouse on Foo](https://www.foo.software/lighthouse)\n`;

    if (isLocalAudit) {
      markdown +=
        'If scores continue to be inconsistent consider [running all audits on Foo]';

      if (isGitHubAction) {
        markdown +=
          '(https://github.com/foo-software/lighthouse-check-action#usage-foos-automated-lighthouse-check-api)\n';
      } else if (isOrb) {
        markdown +=
          '(https://github.com/foo-software/lighthouse-check-orb#usage-foo-api)\n';
      } else {
        markdown +=
          '(https://github.com/foo-software/lighthouse-check#foos-automated-lighthouse-check-api-usage)\n';
      }
    }

    // create an identifier within the comment when searching comments
    // in the future
    const commentIdentifier = '<!-- generated by lighthouse-check -->';
    markdown += commentIdentifier;

    // establish existing comment
    let existingComment;

    // if we aren't saving old comments
    if (!prCommentSaveOld) {
      // get existing comments to see if we've already posted scores
      const existingCommentsResult = await fetch(prCommentUrl, {
        method: 'get',
        headers: {
          'content-type': 'application/json',
          authorization: `token ${prCommentAccessToken}`
        }
      });
      const existingCommentsJsonResult = await existingCommentsResult.json();

      if (
        Array.isArray(existingCommentsJsonResult) &&
        existingCommentsJsonResult.length
      ) {
        existingComment = existingCommentsJsonResult.find(current =>
          current.body.includes(commentIdentifier)
        );
      }
    }

    // create or update the comment with scores
    const shouldUpdate = existingComment && existingComment.id;
    const url = !shouldUpdate
      ? prCommentUrl
      : `${prCommentUrl}/${existingComment.id}`;

    const result = await fetch(url, {
      method: !shouldUpdate ? 'post' : 'put',
      body: JSON.stringify({
        ...(shouldUpdate
          ? {}
          : {
              event: 'COMMENT'
            }),
        body: markdown
      }),
      headers: {
        'content-type': 'application/json',
        authorization: `token ${prCommentAccessToken}`
      }
    });
    const jsonResult = await result.json();

    if (!jsonResult.id) {
      throw new LighthouseCheckError(
        jsonResult.message || 'something went wrong',
        {
          code: ERROR_UNEXPECTED_RESPONSE,
          data: jsonResult
        }
      );
    }
  } catch (error) {
    if (verbose) {
      console.log(`${NAME}:`, error);
    }

    // we still need to kill the process
    throw error;
  }
};

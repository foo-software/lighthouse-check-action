"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.localLighthouse = exports.getLocalLighthouseResultsWithRetries = exports.default = void 0;
var _fs = _interopRequireDefault(require("fs"));
var _lodash = _interopRequireDefault(require("lodash.get"));
var _lighthousePersist = _interopRequireDefault(require("@foo-software/lighthouse-persist"));
var _lighthouseConfig = require("./lighthouseConfig");
var _lighthouseOptions = _interopRequireDefault(require("./lighthouseOptions"));
var _writeResults = _interopRequireDefault(require("./helpers/writeResults"));
var _constants = require("./constants");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const defaultLighthouseConfigs = {
  desktop: _lighthouseConfig.desktop,
  mobile: _lighthouseConfig.mobile
};
const getScoresFromFloat = scores => Object.keys(scores).reduce((accumulator, current) => ({
  ...accumulator,
  ...(typeof scores[current] === 'number' && {
    [current]: Math.floor(scores[current] * 100)
  })
}), {});
const localLighthouse = async ({
  awsAccessKeyId,
  awsBucket,
  awsRegion,
  awsSecretAccessKey,
  emulatedFormFactor,
  extraHeaders,
  locale,
  maxWaitForLoad,
  outputDirectory,
  overrides,
  throttling: throttlingParam,
  throttlingMethod,
  url
}) => {
  // if desktop device, and no throttling param specified, use the
  // appropriate throttling
  const throttlingOverride = emulatedFormFactor === 'desktop' && !throttlingParam ? 'desktopDense4G' : throttlingParam;
  const lighthouseDefaultConfig = defaultLighthouseConfigs[emulatedFormFactor];

  // the default config combined with overriding query params
  const fullConfig = {
    ...lighthouseDefaultConfig,
    settings: {
      ...lighthouseDefaultConfig.settings,
      ...(!maxWaitForLoad ? {} : {
        maxWaitForLoad
      }),
      ...(!throttlingMethod ? {} : {
        throttlingMethod
      }),
      ...(!throttlingOverride || !_lighthouseConfig.throttling[throttlingOverride] ? {} : {
        throttling: _lighthouseConfig.throttling[throttlingOverride]
      }),
      ...(!emulatedFormFactor ? {} : {
        emulatedFormFactor
      }),
      ...(!extraHeaders ? {} : {
        extraHeaders
      }),
      // if we wanted translations (holy!)
      // locale: 'ja',
      ...(!locale ? {} : {
        locale
      })
    },
    ...(!overrides || !overrides.config ? {} : {
      ...overrides.config
    })
  };
  const {
    localReport,
    report,
    result
  } = await (0, _lighthousePersist.default)({
    awsAccessKeyId,
    awsBucket,
    awsRegion,
    awsSecretAccessKey,
    config: fullConfig,
    options: {
      ..._lighthouseOptions.default,
      ...(!overrides || !overrides.options ? {} : {
        ...overrides.options
      })
    },
    outputDirectory,
    url
  });
  const scores = getScoresFromFloat({
    accessibility: (0, _lodash.default)(result, 'categories.accessibility.score'),
    bestPractices: (0, _lodash.default)(result, 'categories["best-practices"].score'),
    performance: (0, _lodash.default)(result, 'categories.performance.score'),
    progressiveWebApp: (0, _lodash.default)(result, 'categories.pwa.score'),
    seo: (0, _lodash.default)(result, 'categories.seo.score')
  });
  return {
    url,
    localReport,
    report,
    emulatedFormFactor,
    runtimeError: (0, _lodash.default)(result, 'runtimeError.message'),
    scores
  };
};
exports.localLighthouse = localLighthouse;
const getLocalLighthouseResultsWithRetries = async ({
  auditConfig,
  localLighthousePromise = localLighthouse,
  maxRetries = 0,
  retries = 0,
  verbose = false
}) => {
  let lighthouseAuditResult;
  try {
    lighthouseAuditResult = await localLighthousePromise(auditConfig);
    if (lighthouseAuditResult.runtimeError) {
      throw Error(lighthouseAuditResult.runtimeError);
    }
    if (maxRetries && retries) {
      console.log(`Succeeded on retry #${retries}.`);
    }
    return lighthouseAuditResult;
  } catch (error) {
    if (retries >= maxRetries) {
      if (maxRetries) {
        console.log(`Max retries of ${maxRetries} exhausted... failing now.`);
      }
      throw error;
    } else {
      if (verbose) {
        console.log(`${_constants.NAME}: Error below caught on retry ${retries} of ${maxRetries}.`, error, 'Trying again...');
      } else {
        console.log(`Error caught on retry ${retries} of ${maxRetries}.`, 'Trying again...');
      }
      return getLocalLighthouseResultsWithRetries({
        auditConfig,
        localLighthousePromise,
        maxRetries,
        retries: retries + 1
      });
    }
  }
};
exports.getLocalLighthouseResultsWithRetries = getLocalLighthouseResultsWithRetries;
var _default = async ({
  awsAccessKeyId,
  awsBucket,
  awsRegion,
  awsSecretAccessKey,
  emulatedFormFactor,
  extraHeaders,
  locale,
  overridesJsonFile,
  maxRetries = 0,
  maxWaitForLoad,
  outputDirectory,
  throttling,
  throttlingMethod,
  urls,
  verbose
}) => {
  // check for overrides config or options
  let overrides;
  if (overridesJsonFile) {
    const overridesJsonString = _fs.default.readFileSync(overridesJsonFile).toString();
    const overridesJson = JSON.parse(overridesJsonString);
    if (overridesJson.config || overridesJson.options) {
      overrides = overridesJson;
    }
  }

  // a list of audit configurations
  const auditConfigs = [];

  // collect all audit configs
  for (const url of urls) {
    const options = {
      awsAccessKeyId,
      awsBucket,
      awsRegion,
      awsSecretAccessKey,
      emulatedFormFactor,
      extraHeaders,
      locale,
      maxWaitForLoad,
      outputDirectory,
      overrides,
      throttling,
      throttlingMethod,
      url,
      verbose
    };
    if (options.emulatedFormFactor !== 'all') {
      auditConfigs.push(options);
    } else {
      // establish two audits for all device types
      auditConfigs.push({
        ...options,
        emulatedFormFactor: 'desktop'
      });
      auditConfigs.push({
        ...options,
        emulatedFormFactor: 'mobile'
      });
    }
  }
  const auditResults = [];
  let index = 1;

  // for each audit config, run the audit
  for (const auditConfig of auditConfigs) {
    if (verbose) {
      console.log(`${_constants.NAME}: Auditing ${auditConfig.emulatedFormFactor} (${index}/${auditConfigs.length}): ${auditConfig.url}`);
    }
    const lighthouseAuditResult = await getLocalLighthouseResultsWithRetries({
      auditConfig,
      maxRetries,
      retries: 0,
      verbose
    });
    auditResults.push(lighthouseAuditResult);
    index++;
  }

  // if outputDirectory is specified write the results to disk
  if (outputDirectory) {
    (0, _writeResults.default)({
      outputDirectory,
      results: auditResults
    });
  }
  return auditResults;
};
exports.default = _default;
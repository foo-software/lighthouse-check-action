"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.localLighthouse = void 0;

var _lodash = _interopRequireDefault(require("lodash.get"));

var _lighthousePersist = _interopRequireDefault(require("@foo-software/lighthouse-persist"));

var _lighthouseConfig = _interopRequireWildcard(require("./lighthouseConfig"));

var _writeResults = _interopRequireDefault(require("./helpers/writeResults"));

var _constants = require("./constants");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; if (obj != null) { var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const getScoresFromFloat = scores => Object.keys(scores).reduce((accumulator, current) => ({ ...accumulator,
  [current]: typeof scores[current] !== 'number' ? 0 : Math.floor(scores[current] * 100)
}), {});

const options = {
  chromeFlags: ['--disable-dev-shm-usage', '--headless', '--no-sandbox', '--ignore-certificate-errors']
};

const localLighthouse = async ({
  awsAccessKeyId,
  awsBucket,
  awsRegion,
  awsSecretAccessKey,
  emulatedFormFactor,
  extraHeaders,
  locale,
  maxWaitForLoad,
  outputDirectory,
  throttling: throttlingOverride,
  throttlingMethod,
  url
}) => {
  // the default config combined with overriding query params
  const fullConfig = { ..._lighthouseConfig.default,
    settings: { ..._lighthouseConfig.default.settings,
      ...(!maxWaitForLoad ? {} : {
        maxWaitForLoad
      }),
      ...(!throttlingMethod ? {} : {
        throttlingMethod
      }),
      ...(!throttlingOverride || !_lighthouseConfig.throttling[throttlingOverride] ? {} : {
        throttling: _lighthouseConfig.throttling[throttlingOverride]
      }),
      ...(!emulatedFormFactor ? {} : {
        emulatedFormFactor
      }),
      ...(!extraHeaders ? {} : {
        extraHeaders
      }),
      // if we wanted translations (holy!)
      // locale: 'ja',
      ...(!locale ? {} : {
        locale
      })
    }
  };
  const {
    localReport,
    report,
    result
  } = await (0, _lighthousePersist.default)({
    awsAccessKeyId,
    awsBucket,
    awsRegion,
    awsSecretAccessKey,
    config: fullConfig,
    options,
    outputDirectory,
    url
  });
  const scores = getScoresFromFloat({
    accessibility: (0, _lodash.default)(result, 'categories.accessibility.score'),
    bestPractices: (0, _lodash.default)(result, 'categories["best-practices"].score'),
    performance: (0, _lodash.default)(result, 'categories.performance.score'),
    progressiveWebApp: (0, _lodash.default)(result, 'categories.pwa.score'),
    seo: (0, _lodash.default)(result, 'categories.seo.score')
  });
  return {
    url,
    localReport,
    report,
    scores
  };
};

exports.localLighthouse = localLighthouse;

var _default = async ({
  awsAccessKeyId,
  awsBucket,
  awsRegion,
  awsSecretAccessKey,
  emulatedFormFactor,
  extraHeaders,
  locale,
  maxWaitForLoad,
  outputDirectory,
  throttling,
  throttlingMethod,
  urls,
  verbose
}) => {
  const auditResults = [];
  let index = 1;

  for (const url of urls) {
    if (verbose) {
      console.log(`${_constants.NAME}: Auditing (${index}/${urls.length}) ${url}`);
    }

    const lighthouseAuditResult = await localLighthouse({
      awsAccessKeyId,
      awsBucket,
      awsRegion,
      awsSecretAccessKey,
      emulatedFormFactor,
      extraHeaders,
      locale,
      maxWaitForLoad,
      outputDirectory,
      throttling,
      throttlingMethod,
      url
    });
    auditResults.push(lighthouseAuditResult);
    index++;
  } // if outputDirectory is specified write the results to disk


  if (outputDirectory) {
    (0, _writeResults.default)({
      outputDirectory,
      results: auditResults
    });
  }

  return auditResults;
};

exports.default = _default;
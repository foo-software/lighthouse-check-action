"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _nodeFetch = _interopRequireDefault(require("node-fetch"));

var _lodash = _interopRequireDefault(require("lodash.get"));

var _LighthouseCheckError = _interopRequireDefault(require("./LighthouseCheckError"));

var _constants = require("./constants");

var _errorCodes = require("./errorCodes");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = async ({
  apiToken,
  tag,
  urls = [],
  verbose = true
}) => {
  try {
    let apiTokens = urls;

    if (!Array.isArray(urls) || !urls.length) {
      if (verbose) {
        console.log(`${_constants.NAME}:`, 'Fetching URLs from account.');
      }

      const pagesResponse = await (0, _nodeFetch.default)(`${_constants.API_URL}${_constants.API_PAGES_PATH}`, {
        method: 'get',
        headers: {
          Authorization: apiToken,
          'Content-Type': 'application/json'
        }
      });
      const pagesJson = await pagesResponse.json();

      if (pagesJson.status >= 400) {
        const errorMessage = `Account wasn't found for the provided API token.`;

        if (verbose) {
          console.log(`${_constants.NAME}:`, errorMessage);
        }

        throw new _LighthouseCheckError.default(errorMessage, {
          code: _errorCodes.ERROR_UNAUTHORIZED
        });
      }

      const pages = (0, _lodash.default)(pagesJson, 'data.page', []);

      if (!pages.length) {
        const errorMessage = 'No URLs were found for this account.';

        if (verbose) {
          console.log(`${_constants.NAME}:`, errorMessage);
        }

        throw new _LighthouseCheckError.default(errorMessage, {
          code: _errorCodes.ERROR_NO_URLS
        });
      }

      apiTokens = pages.map(current => current.apiToken);
    }

    if (verbose) {
      console.log(`${_constants.NAME}:`, 'Enqueueing Lighthouse audits.');
    } // enqueue urls for Lighthouse audits


    const queueItemsResponse = await (0, _nodeFetch.default)(`${_constants.API_URL}${_constants.API_QUEUE_ITEMS_PATH}`, {
      method: 'post',
      headers: {
        Authorization: apiToken,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        tag: tag || _constants.DEFAULT_TAG,
        pages: apiTokens.join(),
        type: _constants.TRIGGER_TYPE
      })
    });
    const queueItemsJson = await queueItemsResponse.json();
    const queue = (0, _lodash.default)(queueItemsJson, 'data.queue'); // if no results

    if (!queue.results.length) {
      const errorMessage = 'No results.';

      if (verbose) {
        console.log(`${_constants.NAME}:`, errorMessage);
      }

      throw new _LighthouseCheckError.default(errorMessage, {
        code: _errorCodes.ERROR_NO_RESULTS
      });
    } // if all urls failed to be enqueued...


    if (queue.errors === queue.results.length) {
      const errorCode = queue.results[0].code;
      const errorMessage = errorCode === _errorCodes.ERROR_QUEUE_MAX_USED_DAY ? queue.results[0].message : 'All URLs failed to be enqueued. Examine the "data" property of this error for details.';

      if (verbose) {
        console.log(`${_constants.NAME}:`, errorMessage);
      }

      throw new _LighthouseCheckError.default(errorMessage, {
        code: errorCode,
        data: queue.results
      });
    } // if only some urls succeeded to be enqueued...


    const successResultLength = queue.results.length - queue.errors;
    const message = successResultLength < queue.results.length ? `Only ${successResultLength > 1 ? 'some' : 'one'} of your account URLs were enqueued. Typically this occurs when daily limit has been met for a given URL. Check your account limits online.` : `${queue.results.length} ${queue.results.length > 1 ? 'URLs' : 'URL'} successfully enqueued for Lighthouse. Visit dashboard for results.`;

    if (verbose) {
      console.log(`${_constants.NAME}:`, message);
    } // success


    return {
      code: _constants.SUCCESS_CODE_GENERIC,
      data: queue.results,
      message
    };
  } catch (error) {
    const result = {
      code: error.code || _errorCodes.ERROR_GENERIC,
      error
    }; // if an error occurred but we still have data (typically if only some URLs failed)

    if (error.data) {
      result.data = error.data;
    }

    return result;
  }
};

exports.default = _default;
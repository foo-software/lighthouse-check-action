"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _path = _interopRequireDefault(require("path"));

var _fetchAndWaitForLighthouseAudits = _interopRequireDefault(require("./fetchAndWaitForLighthouseAudits"));

var _LighthouseCheckError = _interopRequireDefault(require("./LighthouseCheckError"));

var _triggerLighthouse = _interopRequireDefault(require("./triggerLighthouse"));

var _localLighthouse = _interopRequireDefault(require("./localLighthouse"));

var _postPrComment = _interopRequireDefault(require("./postPrComment"));

var _slackNotify = _interopRequireDefault(require("./slackNotify"));

var _writeResults = _interopRequireDefault(require("./helpers/writeResults"));

var _constants = require("./constants");

var _errorCodes = require("./errorCodes");

var _logResults = _interopRequireDefault(require("./logResults"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = ({
  apiToken,
  author,
  awsAccessKeyId,
  awsBucket,
  awsRegion,
  awsSecretAccessKey,
  // `device` and `emulatedFormFactor` are the same things, but we
  // support them both to accommodate older consumers. `device` should
  // be the standard moving forward.
  device,
  // we should really update this someday to use `formFactor` which
  // is now used by Lighthouse
  emulatedFormFactor: paramEmulatedFormFactor = 'mobile',
  extraHeaders,
  branch,
  isGitHubAction,
  isOrb,
  locale,
  maxWaitForLoad,
  maxRetries = 0,
  outputDirectory,
  overridesJsonFile,
  pr,
  prCommentAccessToken,
  prCommentEnabled = true,
  prCommentSaveOld = false,
  prCommentUrl,
  sha,
  tag,
  throttling,
  throttlingMethod,
  timeout,
  urls,
  verbose = true,
  wait = true,
  slackWebhookUrl
}) => new Promise(async (resolve, reject) => {
  try {
    const emulatedFormFactor = device || paramEmulatedFormFactor;
    const outputDirectoryPath = !outputDirectory ? outputDirectory : _path.default.resolve(outputDirectory); // we either get the result from the API or directly from
    // running a lighthouse audit locally.

    const isLocalAudit = !apiToken; // if we're auditing through the foo.software API,
    // otherwise we're using Lighthouse directly, locally

    if (!isLocalAudit) {
      const triggerResult = await (0, _triggerLighthouse.default)({
        apiToken,
        device: emulatedFormFactor,
        isGitHubAction,
        isOrb,
        tag,
        timeout,
        urls,
        verbose
      });

      if (triggerResult.error) {
        reject(triggerResult.error);
        return;
      } // if the user understandably doesn't want to wait for results, return right away


      if (!wait) {
        resolve(triggerResult);
        return;
      } // if this condition doesn't pass - we got a problem


      if (triggerResult.data) {
        // assemble an array of queueIds
        const queueIds = triggerResult.data.reduce((accumulator, current) => [...accumulator, ...(!current.id ? [] : [current.id])], []); // if this condition doesn't pass - we got a problem

        if (queueIds.length) {
          if (!verbose) {
            console.log('\n');
          }

          const auditResults = await (0, _fetchAndWaitForLighthouseAudits.default)({
            apiToken,
            queueIds,
            timeout,
            verbose
          }); // if output directory is specified write the results to disk

          if (outputDirectoryPath) {
            (0, _writeResults.default)({
              outputDirectory: outputDirectoryPath,
              results: auditResults
            });
          }

          if (slackWebhookUrl) {
            await (0, _slackNotify.default)({
              author,
              branch,
              pr,
              results: auditResults,
              sha,
              slackWebhookUrl,
              verbose
            });
          }

          if (prCommentEnabled && prCommentUrl && prCommentAccessToken) {
            await (0, _postPrComment.default)({
              isGitHubAction,
              isLocalAudit,
              isOrb,
              prCommentAccessToken,
              prCommentSaveOld,
              prCommentUrl,
              results: auditResults,
              verbose
            });
          }

          (0, _logResults.default)({
            isGitHubAction,
            isLocalAudit,
            isOrb,
            results: auditResults
          }); // success

          resolve({
            code: _constants.SUCCESS_CODE_GENERIC,
            data: auditResults
          });
          return;
        }
      }

      const errorMessage = 'Failed to retrieve results.';

      if (verbose) {
        console.log(`${_constants.NAME}:`, errorMessage);
      }

      reject(new _LighthouseCheckError.default(errorMessage, {
        code: _errorCodes.ERROR_NO_RESULTS
      }));
    } else {
      const lighthouseAudits = await (0, _localLighthouse.default)({
        awsAccessKeyId,
        awsBucket,
        awsRegion,
        awsSecretAccessKey,
        emulatedFormFactor,
        extraHeaders,
        locale,
        maxRetries,
        maxWaitForLoad,
        outputDirectory: outputDirectoryPath,
        overridesJsonFile: overridesJsonFile && _path.default.resolve(overridesJsonFile),
        throttling,
        throttlingMethod,
        urls,
        verbose
      });

      if (!lighthouseAudits.length) {
        reject(new _LighthouseCheckError.default('Something went wrong - no results.', {
          code: _errorCodes.ERROR_NO_RESULTS
        }));
      } else {
        if (slackWebhookUrl) {
          await (0, _slackNotify.default)({
            author,
            branch,
            pr,
            results: lighthouseAudits,
            sha,
            slackWebhookUrl,
            verbose
          });
        }

        if (prCommentEnabled && prCommentUrl && prCommentAccessToken) {
          await (0, _postPrComment.default)({
            isGitHubAction,
            isLocalAudit,
            isOrb,
            prCommentAccessToken,
            prCommentSaveOld,
            prCommentUrl,
            results: lighthouseAudits,
            verbose
          });
        }

        (0, _logResults.default)({
          isGitHubAction,
          isLocalAudit,
          isOrb,
          results: lighthouseAudits
        }); // success

        resolve({
          code: _constants.SUCCESS_CODE_GENERIC,
          data: lighthouseAudits
        });
      }
    }
  } catch (error) {
    if (verbose) {
      console.log(`${_constants.NAME}:\n`, error);
    }

    reject(error);
  }
});

exports.default = _default;
"use strict";
/**
 * Copyright 2022 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BrowsingContextImpl = void 0;
const protocol_js_1 = require("../../../protocol/protocol.js");
const log_js_1 = require("../../../utils/log.js");
const deferred_js_1 = require("../../../utils/deferred.js");
const logManager_js_1 = require("../log/logManager.js");
const realm_js_1 = require("../script/realm.js");
class BrowsingContextImpl {
    #targetDefers = {
        documentInitialized: new deferred_js_1.Deferred(),
        targetUnblocked: new deferred_js_1.Deferred(),
        Page: {
            navigatedWithinDocument: new deferred_js_1.Deferred(),
            lifecycleEvent: {
                DOMContentLoaded: new deferred_js_1.Deferred(),
                load: new deferred_js_1.Deferred(),
            },
        },
    };
    #contextId;
    #parentId;
    #cdpBrowserContextId;
    #eventManager;
    #children = new Map();
    #realmStorage;
    #url = 'about:blank';
    #loaderId = null;
    #cdpSessionId;
    #cdpClient;
    #maybeDefaultRealm;
    #browsingContextStorage;
    #logger;
    get #defaultRealm() {
        if (this.#maybeDefaultRealm === undefined) {
            throw new Error(`No default realm for browsing context ${this.#contextId}`);
        }
        return this.#maybeDefaultRealm;
    }
    constructor(realmStorage, contextId, parentId, cdpClient, cdpSessionId, cdpBrowserContextId, eventManager, browsingContextStorage, logger) {
        this.#realmStorage = realmStorage;
        this.#contextId = contextId;
        this.#parentId = parentId;
        this.#cdpClient = cdpClient;
        this.#cdpBrowserContextId = cdpBrowserContextId;
        this.#eventManager = eventManager;
        this.#cdpSessionId = cdpSessionId;
        this.#browsingContextStorage = browsingContextStorage;
        this.#logger = logger;
        this.#initListeners();
        this.#browsingContextStorage.addContext(this);
    }
    static async createFrameContext(realmStorage, contextId, parentId, cdpClient, cdpSessionId, eventManager, browsingContextStorage, logger) {
        const context = new BrowsingContextImpl(realmStorage, contextId, parentId, cdpClient, cdpSessionId, null, eventManager, browsingContextStorage, logger);
        context.#targetDefers.targetUnblocked.resolve();
        await eventManager.registerEvent({
            method: protocol_js_1.BrowsingContext.EventNames.ContextCreatedEvent,
            params: context.serializeToBidiValue(),
        }, context.contextId);
    }
    static async createTargetContext(realmStorage, contextId, parentId, cdpClient, cdpSessionId, cdpBrowserContextId, eventManager, browsingContextStorage, logger) {
        const context = new BrowsingContextImpl(realmStorage, contextId, parentId, cdpClient, cdpSessionId, cdpBrowserContextId, eventManager, browsingContextStorage, logger);
        // No need in waiting for target to be unblocked.
        // noinspection ES6MissingAwait
        context.#unblockAttachedTarget();
        await eventManager.registerEvent({
            method: protocol_js_1.BrowsingContext.EventNames.ContextCreatedEvent,
            params: context.serializeToBidiValue(),
        }, context.contextId);
    }
    get cdpBrowserContextId() {
        return this.#cdpBrowserContextId;
    }
    // https://html.spec.whatwg.org/multipage/document-sequences.html#navigable
    get navigableId() {
        return this.#loaderId;
    }
    convertFrameToTargetContext(cdpClient, cdpSessionId) {
        this.#updateConnection(cdpClient, cdpSessionId);
        // No need in waiting for target to be unblocked.
        // noinspection JSIgnoredPromiseFromCall
        this.#unblockAttachedTarget();
    }
    async delete() {
        await this.#removeChildContexts();
        this.#realmStorage.deleteRealms({
            browsingContextId: this.contextId,
        });
        // Remove context from the parent.
        if (this.parentId !== null) {
            const parent = this.#browsingContextStorage.getKnownContext(this.parentId);
            parent.#children.delete(this.contextId);
        }
        await this.#eventManager.registerEvent({
            method: protocol_js_1.BrowsingContext.EventNames.ContextDestroyedEvent,
            params: this.serializeToBidiValue(),
        }, this.contextId);
        this.#browsingContextStorage.removeContext(this.contextId);
    }
    async #removeChildContexts() {
        await Promise.all(this.children.map((child) => child.delete()));
    }
    #updateConnection(cdpClient, cdpSessionId) {
        if (this.#targetDefers.targetUnblocked.isFinished) {
            this.#targetDefers.targetUnblocked = new deferred_js_1.Deferred();
        }
        else {
            this.#logger?.(log_js_1.LogType.browsingContexts, 'targetUnblocked postponed because of OOPiF');
        }
        this.#cdpClient = cdpClient;
        this.#cdpSessionId = cdpSessionId;
        this.#initListeners();
    }
    async #unblockAttachedTarget() {
        logManager_js_1.LogManager.create(this.#realmStorage, this.#cdpClient, this.#cdpSessionId, this.#eventManager);
        await this.#cdpClient.sendCommand('Runtime.enable');
        await this.#cdpClient.sendCommand('Page.enable');
        await this.#cdpClient.sendCommand('Page.setLifecycleEventsEnabled', {
            enabled: true,
        });
        await this.#cdpClient.sendCommand('Target.setAutoAttach', {
            autoAttach: true,
            waitForDebuggerOnStart: true,
            flatten: true,
        });
        await this.#cdpClient.sendCommand('Runtime.runIfWaitingForDebugger');
        this.#targetDefers.targetUnblocked.resolve();
    }
    get contextId() {
        return this.#contextId;
    }
    get parentId() {
        return this.#parentId;
    }
    get cdpSessionId() {
        return this.#cdpSessionId;
    }
    get children() {
        return Array.from(this.#children.values());
    }
    get url() {
        return this.#url;
    }
    addChild(child) {
        this.#children.set(child.contextId, child);
    }
    async awaitLoaded() {
        await this.#targetDefers.Page.lifecycleEvent.load;
    }
    async awaitUnblocked() {
        await this.#targetDefers.targetUnblocked;
    }
    serializeToBidiValue(maxDepth = 0, addParentFiled = true) {
        return {
            context: this.#contextId,
            url: this.url,
            children: maxDepth > 0
                ? this.children.map((c) => c.serializeToBidiValue(maxDepth - 1, false))
                : null,
            ...(addParentFiled ? { parent: this.#parentId } : {}),
        };
    }
    #initListeners() {
        this.#cdpClient.on('Target.targetInfoChanged', (params) => {
            if (this.contextId !== params.targetInfo.targetId) {
                return;
            }
            this.#url = params.targetInfo.url;
        });
        this.#cdpClient.on('Page.frameNavigated', async (params) => {
            if (this.contextId !== params.frame.id) {
                return;
            }
            this.#url = params.frame.url + (params.frame.urlFragment ?? '');
            // At the point the page is initiated, all the nested iframes from the
            // previous page are detached and realms are destroyed.
            // Remove context's children.
            await this.#removeChildContexts();
            // Remove all the already created realms.
            this.#realmStorage.deleteRealms({ browsingContextId: this.contextId });
        });
        this.#cdpClient.on('Page.navigatedWithinDocument', (params) => {
            if (this.contextId !== params.frameId) {
                return;
            }
            this.#url = params.url;
            this.#targetDefers.Page.navigatedWithinDocument.resolve(params);
        });
        this.#cdpClient.on('Page.lifecycleEvent', async (params) => {
            if (this.contextId !== params.frameId) {
                return;
            }
            if (params.name === 'init') {
                this.#documentChanged(params.loaderId);
                this.#targetDefers.documentInitialized.resolve();
            }
            if (params.name === 'commit') {
                this.#loaderId = params.loaderId;
                return;
            }
            if (params.loaderId !== this.#loaderId) {
                return;
            }
            switch (params.name) {
                case 'DOMContentLoaded':
                    this.#targetDefers.Page.lifecycleEvent.DOMContentLoaded.resolve(params);
                    await this.#eventManager.registerEvent({
                        method: protocol_js_1.BrowsingContext.EventNames.DomContentLoadedEvent,
                        params: {
                            context: this.contextId,
                            navigation: this.#loaderId,
                            url: this.#url,
                        },
                    }, this.contextId);
                    break;
                case 'load':
                    this.#targetDefers.Page.lifecycleEvent.load.resolve(params);
                    await this.#eventManager.registerEvent({
                        method: protocol_js_1.BrowsingContext.EventNames.LoadEvent,
                        params: {
                            context: this.contextId,
                            navigation: this.#loaderId,
                            url: this.#url,
                        },
                    }, this.contextId);
                    break;
            }
        });
        this.#cdpClient.on('Runtime.executionContextCreated', (params) => {
            if (params.context.auxData.frameId !== this.contextId) {
                return;
            }
            // Only this execution contexts are supported for now.
            if (!['default', 'isolated'].includes(params.context.auxData.type)) {
                return;
            }
            const realm = new realm_js_1.Realm(this.#realmStorage, this.#browsingContextStorage, params.context.uniqueId, this.contextId, params.context.id, this.#getOrigin(params), 
            // TODO: differentiate types.
            'window', 
            // Sandbox name for isolated world.
            params.context.auxData.type === 'isolated'
                ? params.context.name
                : undefined, this.#cdpSessionId, this.#cdpClient);
            if (params.context.auxData.isDefault) {
                this.#maybeDefaultRealm = realm;
            }
        });
        this.#cdpClient.on('Runtime.executionContextDestroyed', (params) => {
            this.#realmStorage.deleteRealms({
                cdpSessionId: this.#cdpSessionId,
                executionContextId: params.executionContextId,
            });
        });
    }
    #getOrigin(params) {
        if (params.context.auxData.type === 'isolated') {
            // Sandbox should have the same origin as the context itself, but in CDP
            // it has an empty one.
            return this.#defaultRealm.origin;
        }
        // https://html.spec.whatwg.org/multipage/origin.html#ascii-serialisation-of-an-origin
        return ['://', ''].includes(params.context.origin)
            ? 'null'
            : params.context.origin;
    }
    #documentChanged(loaderId) {
        // Same document navigation.
        if (loaderId === undefined || this.#loaderId === loaderId) {
            if (this.#targetDefers.Page.navigatedWithinDocument.isFinished) {
                this.#targetDefers.Page.navigatedWithinDocument =
                    new deferred_js_1.Deferred();
            }
            return;
        }
        if (this.#targetDefers.documentInitialized.isFinished) {
            this.#targetDefers.documentInitialized = new deferred_js_1.Deferred();
        }
        else {
            this.#logger?.(log_js_1.LogType.browsingContexts, 'Document changed');
        }
        if (this.#targetDefers.Page.lifecycleEvent.DOMContentLoaded.isFinished) {
            this.#targetDefers.Page.lifecycleEvent.DOMContentLoaded =
                new deferred_js_1.Deferred();
        }
        else {
            this.#logger?.(log_js_1.LogType.browsingContexts, 'Document changed');
        }
        if (this.#targetDefers.Page.lifecycleEvent.load.isFinished) {
            this.#targetDefers.Page.lifecycleEvent.load =
                new deferred_js_1.Deferred();
        }
        else {
            this.#logger?.(log_js_1.LogType.browsingContexts, 'Document changed');
        }
        this.#loaderId = loaderId;
    }
    async navigate(url, wait) {
        await this.#targetDefers.targetUnblocked;
        // TODO: handle loading errors.
        const cdpNavigateResult = await this.#cdpClient.sendCommand('Page.navigate', {
            url,
            frameId: this.contextId,
        });
        if (cdpNavigateResult.errorText) {
            throw new protocol_js_1.Message.UnknownException(cdpNavigateResult.errorText);
        }
        this.#documentChanged(cdpNavigateResult.loaderId);
        // Wait for `wait` condition.
        switch (wait) {
            case 'none':
                break;
            case 'interactive':
                // No `loaderId` means same-document navigation.
                if (cdpNavigateResult.loaderId === undefined) {
                    await this.#targetDefers.Page.navigatedWithinDocument;
                }
                else {
                    await this.#targetDefers.Page.lifecycleEvent.DOMContentLoaded;
                }
                break;
            case 'complete':
                // No `loaderId` means same-document navigation.
                if (cdpNavigateResult.loaderId === undefined) {
                    await this.#targetDefers.Page.navigatedWithinDocument;
                }
                else {
                    await this.#targetDefers.Page.lifecycleEvent.load;
                }
                break;
            default:
                throw new Error(`Not implemented wait '${wait}'`);
        }
        return {
            result: {
                navigation: cdpNavigateResult.loaderId || null,
                url: url,
            },
        };
    }
    async getOrCreateSandbox(sandbox) {
        if (sandbox === undefined || sandbox === '') {
            return this.#defaultRealm;
        }
        let maybeSandboxes = this.#realmStorage.findRealms({
            browsingContextId: this.contextId,
            sandbox,
        });
        if (maybeSandboxes.length === 0) {
            await this.#cdpClient.sendCommand('Page.createIsolatedWorld', {
                frameId: this.contextId,
                worldName: sandbox,
            });
            // `Runtime.executionContextCreated` should be emitted by the time the
            // previous command is done.
            maybeSandboxes = this.#realmStorage.findRealms({
                browsingContextId: this.contextId,
                sandbox,
            });
        }
        if (maybeSandboxes.length !== 1) {
            throw Error(`Sandbox ${sandbox} wasn't created.`);
        }
        return maybeSandboxes[0];
    }
}
exports.BrowsingContextImpl = BrowsingContextImpl;
//# sourceMappingURL=browsingContextImpl.js.map
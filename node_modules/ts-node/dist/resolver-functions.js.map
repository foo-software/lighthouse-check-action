{"version":3,"file":"resolver-functions.js","sourceRoot":"","sources":["../src/resolver-functions.ts"],"names":[],"mappings":"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","sourcesContent":["import { resolve } from 'path';\nimport type * as _ts from 'typescript';\n\n/**\n * @internal\n * In a factory because these are shared across both CompilerHost and LanguageService codepaths\n */\nexport function createResolverFunctions(kwargs: {\n  ts: typeof _ts;\n  serviceHost: _ts.ModuleResolutionHost;\n  cwd: string;\n  getCanonicalFileName: (filename: string) => string;\n  config: _ts.ParsedCommandLine;\n  configFilePath: string | undefined;\n}) {\n  const {\n    serviceHost,\n    ts,\n    config,\n    cwd,\n    getCanonicalFileName,\n    configFilePath,\n  } = kwargs;\n  const moduleResolutionCache = ts.createModuleResolutionCache(\n    cwd,\n    getCanonicalFileName,\n    config.options\n  );\n  const knownInternalFilenames = new Set<string>();\n  /** \"Buckets\" (module directories) whose contents should be marked \"internal\" */\n  const internalBuckets = new Set<string>();\n\n  // Get bucket for a source filename.  Bucket is the containing `./node_modules/*/` directory\n  // For '/project/node_modules/foo/node_modules/bar/lib/index.js' bucket is '/project/node_modules/foo/node_modules/bar/'\n  // For '/project/node_modules/foo/node_modules/@scope/bar/lib/index.js' bucket is '/project/node_modules/foo/node_modules/@scope/bar/'\n  const moduleBucketRe = /.*\\/node_modules\\/(?:@[^\\/]+\\/)?[^\\/]+\\//;\n  function getModuleBucket(filename: string) {\n    const find = moduleBucketRe.exec(filename);\n    if (find) return find[0];\n    return '';\n  }\n\n  // Mark that this file and all siblings in its bucket should be \"internal\"\n  function markBucketOfFilenameInternal(filename: string) {\n    internalBuckets.add(getModuleBucket(filename));\n  }\n\n  function isFileInInternalBucket(filename: string) {\n    return internalBuckets.has(getModuleBucket(filename));\n  }\n\n  function isFileKnownToBeInternal(filename: string) {\n    return knownInternalFilenames.has(filename);\n  }\n\n  /**\n   * If we need to emit JS for a file, force TS to consider it non-external\n   */\n  const fixupResolvedModule = (\n    resolvedModule: _ts.ResolvedModule | _ts.ResolvedTypeReferenceDirective\n  ) => {\n    const { resolvedFileName } = resolvedModule;\n    if (resolvedFileName === undefined) return;\n    // .ts is always switched to internal\n    // .js is switched on-demand\n    if (\n      resolvedModule.isExternalLibraryImport &&\n      ((resolvedFileName.endsWith('.ts') &&\n        !resolvedFileName.endsWith('.d.ts')) ||\n        isFileKnownToBeInternal(resolvedFileName) ||\n        isFileInInternalBucket(resolvedFileName))\n    ) {\n      resolvedModule.isExternalLibraryImport = false;\n    }\n    if (!resolvedModule.isExternalLibraryImport) {\n      knownInternalFilenames.add(resolvedFileName);\n    }\n  };\n  /*\n   * NOTE:\n   * Older ts versions do not pass `redirectedReference` nor `options`.\n   * We must pass `redirectedReference` to newer ts versions, but cannot rely on `options`, hence the weird argument name\n   */\n  const resolveModuleNames: _ts.LanguageServiceHost['resolveModuleNames'] = (\n    moduleNames: string[],\n    containingFile: string,\n    reusedNames: string[] | undefined,\n    redirectedReference: _ts.ResolvedProjectReference | undefined,\n    optionsOnlyWithNewerTsVersions: _ts.CompilerOptions\n  ): (_ts.ResolvedModule | undefined)[] => {\n    return moduleNames.map((moduleName) => {\n      const { resolvedModule } = ts.resolveModuleName(\n        moduleName,\n        containingFile,\n        config.options,\n        serviceHost,\n        moduleResolutionCache,\n        redirectedReference\n      );\n      if (resolvedModule) {\n        fixupResolvedModule(resolvedModule);\n      }\n      return resolvedModule;\n    });\n  };\n\n  // language service never calls this, but TS docs recommend that we implement it\n  const getResolvedModuleWithFailedLookupLocationsFromCache: _ts.LanguageServiceHost['getResolvedModuleWithFailedLookupLocationsFromCache'] = (\n    moduleName,\n    containingFile\n  ): _ts.ResolvedModuleWithFailedLookupLocations | undefined => {\n    const ret = ts.resolveModuleNameFromCache(\n      moduleName,\n      containingFile,\n      moduleResolutionCache\n    );\n    if (ret && ret.resolvedModule) {\n      fixupResolvedModule(ret.resolvedModule);\n    }\n    return ret;\n  };\n\n  const resolveTypeReferenceDirectives: _ts.LanguageServiceHost['resolveTypeReferenceDirectives'] = (\n    typeDirectiveNames: string[],\n    containingFile: string,\n    redirectedReference: _ts.ResolvedProjectReference | undefined,\n    options: _ts.CompilerOptions\n  ): (_ts.ResolvedTypeReferenceDirective | undefined)[] => {\n    // Note: seems to be called with empty typeDirectiveNames array for all files.\n    return typeDirectiveNames.map((typeDirectiveName) => {\n      let { resolvedTypeReferenceDirective } = ts.resolveTypeReferenceDirective(\n        typeDirectiveName,\n        containingFile,\n        config.options,\n        serviceHost,\n        redirectedReference\n      );\n      if (typeDirectiveName === 'node' && !resolvedTypeReferenceDirective) {\n        // Resolve @types/node relative to project first, then __dirname (copy logic from elsewhere / refactor into reusable function)\n        let typesNodePackageJsonPath: string | undefined;\n        try {\n          typesNodePackageJsonPath = require.resolve(\n            '@types/node/package.json',\n            {\n              paths: [configFilePath ?? cwd, __dirname],\n            }\n          );\n        } catch {} // gracefully do nothing when @types/node is not installed for any reason\n        if (typesNodePackageJsonPath) {\n          const typeRoots = [resolve(typesNodePackageJsonPath, '../..')];\n          ({\n            resolvedTypeReferenceDirective,\n          } = ts.resolveTypeReferenceDirective(\n            typeDirectiveName,\n            containingFile,\n            {\n              ...config.options,\n              typeRoots,\n            },\n            serviceHost,\n            redirectedReference\n          ));\n        }\n      }\n      if (resolvedTypeReferenceDirective) {\n        fixupResolvedModule(resolvedTypeReferenceDirective);\n      }\n      return resolvedTypeReferenceDirective;\n    });\n  };\n\n  return {\n    resolveModuleNames,\n    getResolvedModuleWithFailedLookupLocationsFromCache,\n    resolveTypeReferenceDirectives,\n    isFileKnownToBeInternal,\n    markBucketOfFilenameInternal,\n  };\n}\n"]}
{"version":3,"file":"esm.js","sourceRoot":"","sources":["../src/esm.ts"],"names":[],"mappings":"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","sourcesContent":["import { register, getExtensions, RegisterOptions } from './index';\nimport {\n  parse as parseUrl,\n  format as formatUrl,\n  UrlWithStringQuery,\n  fileURLToPath,\n  pathToFileURL,\n} from 'url';\nimport { extname } from 'path';\nimport * as assert from 'assert';\nimport { normalizeSlashes } from './util';\nconst {\n  createResolve,\n} = require('../dist-raw/node-esm-resolve-implementation');\n\n// Note: On Windows, URLs look like this: file:///D:/dev/@TypeStrong/ts-node-examples/foo.ts\n\nexport function registerAndCreateEsmHooks(opts?: RegisterOptions) {\n  // Automatically performs registration just like `-r ts-node/register`\n  const tsNodeInstance = register({\n    ...opts,\n    experimentalEsmLoader: true,\n  });\n\n  // Custom implementation that considers additional file extensions and automatically adds file extensions\n  const nodeResolveImplementation = createResolve({\n    ...getExtensions(tsNodeInstance.config),\n    preferTsExts: tsNodeInstance.options.preferTsExts,\n  });\n\n  return { resolve, getFormat, transformSource };\n\n  function isFileUrlOrNodeStyleSpecifier(parsed: UrlWithStringQuery) {\n    // We only understand file:// URLs, but in node, the specifier can be a node-style `./foo` or `foo`\n    const { protocol } = parsed;\n    return protocol === null || protocol === 'file:';\n  }\n\n  async function resolve(\n    specifier: string,\n    context: { parentURL: string },\n    defaultResolve: typeof resolve\n  ): Promise<{ url: string }> {\n    const defer = async () => {\n      const r = await defaultResolve(specifier, context, defaultResolve);\n      return r;\n    };\n\n    const parsed = parseUrl(specifier);\n    const { pathname, protocol, hostname } = parsed;\n\n    if (!isFileUrlOrNodeStyleSpecifier(parsed)) {\n      return defer();\n    }\n\n    if (protocol !== null && protocol !== 'file:') {\n      return defer();\n    }\n\n    // Malformed file:// URL?  We should always see `null` or `''`\n    if (hostname) {\n      // TODO file://./foo sets `hostname` to `'.'`.  Perhaps we should special-case this.\n      return defer();\n    }\n\n    // pathname is the path to be resolved\n\n    return nodeResolveImplementation.defaultResolve(\n      specifier,\n      context,\n      defaultResolve\n    );\n  }\n\n  type Format = 'builtin' | 'commonjs' | 'dynamic' | 'json' | 'module' | 'wasm';\n  async function getFormat(\n    url: string,\n    context: {},\n    defaultGetFormat: typeof getFormat\n  ): Promise<{ format: Format }> {\n    const defer = (overrideUrl: string = url) =>\n      defaultGetFormat(overrideUrl, context, defaultGetFormat);\n\n    const parsed = parseUrl(url);\n\n    if (!isFileUrlOrNodeStyleSpecifier(parsed)) {\n      return defer();\n    }\n\n    const { pathname } = parsed;\n    assert(\n      pathname !== null,\n      'ESM getFormat() hook: URL should never have null pathname'\n    );\n\n    const nativePath = fileURLToPath(url);\n\n    // If file has .ts, .tsx, or .jsx extension, then ask node how it would treat this file if it were .js\n    const ext = extname(nativePath);\n    let nodeSays: { format: Format };\n    if (ext !== '.js' && !tsNodeInstance.ignored(nativePath)) {\n      nodeSays = await defer(formatUrl(pathToFileURL(nativePath + '.js')));\n    } else {\n      nodeSays = await defer();\n    }\n    // For files compiled by ts-node that node believes are either CJS or ESM, check if we should override that classification\n    if (\n      !tsNodeInstance.ignored(nativePath) &&\n      (nodeSays.format === 'commonjs' || nodeSays.format === 'module')\n    ) {\n      const { moduleType } = tsNodeInstance.moduleTypeClassifier.classifyModule(\n        normalizeSlashes(nativePath)\n      );\n      if (moduleType === 'cjs') {\n        return { format: 'commonjs' };\n      } else if (moduleType === 'esm') {\n        return { format: 'module' };\n      }\n    }\n    return nodeSays;\n  }\n\n  async function transformSource(\n    source: string | Buffer,\n    context: { url: string; format: Format },\n    defaultTransformSource: typeof transformSource\n  ): Promise<{ source: string | Buffer }> {\n    const defer = () =>\n      defaultTransformSource(source, context, defaultTransformSource);\n\n    const sourceAsString =\n      typeof source === 'string' ? source : source.toString('utf8');\n\n    const { url } = context;\n    const parsed = parseUrl(url);\n\n    if (!isFileUrlOrNodeStyleSpecifier(parsed)) {\n      return defer();\n    }\n    const nativePath = fileURLToPath(url);\n\n    if (tsNodeInstance.ignored(nativePath)) {\n      return defer();\n    }\n\n    const emittedJs = tsNodeInstance.compile(sourceAsString, nativePath);\n\n    return { source: emittedJs };\n  }\n}\n"]}
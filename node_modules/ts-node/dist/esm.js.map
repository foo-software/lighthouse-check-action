{"version":3,"file":"esm.js","sourceRoot":"","sources":["../src/esm.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  register,\n  getExtensions,\n  RegisterOptions,\n  Service,\n  versionGteLt,\n} from './index';\nimport {\n  parse as parseUrl,\n  format as formatUrl,\n  UrlWithStringQuery,\n  fileURLToPath,\n  pathToFileURL,\n} from 'url';\nimport { extname } from 'path';\nimport * as assert from 'assert';\nimport { normalizeSlashes } from './util';\nconst {\n  createResolve,\n} = require('../dist-raw/node-esm-resolve-implementation');\nconst { defaultGetFormat } = require('../dist-raw/node-esm-default-get-format');\n\n// Note: On Windows, URLs look like this: file:///D:/dev/@TypeStrong/ts-node-examples/foo.ts\n\n// NOTE ABOUT MULTIPLE EXPERIMENTAL LOADER APIS\n//\n// At the time of writing, this file implements 2x different loader APIs.\n// Node made a breaking change to the loader API in https://github.com/nodejs/node/pull/37468\n//\n// We check the node version number and export either the *old* or the *new* API.\n//\n// Today, we are implementing the *new* API on top of our implementation of the *old* API,\n// which relies on copy-pasted code from the *old* hooks implementation in node.\n//\n// In the future, we will likely invert this: we will copy-paste the *new* API implementation\n// from node, build our implementation of the *new* API on top of it, and implement the *old*\n// hooks API as a shim to the *new* API.\n\n/** @internal */\nexport function registerAndCreateEsmHooks(opts?: RegisterOptions) {\n  // Automatically performs registration just like `-r ts-node/register`\n  const tsNodeInstance = register(opts);\n\n  return createEsmHooks(tsNodeInstance);\n}\n\nexport function createEsmHooks(tsNodeService: Service) {\n  tsNodeService.enableExperimentalEsmLoaderInterop();\n\n  // Custom implementation that considers additional file extensions and automatically adds file extensions\n  const nodeResolveImplementation = createResolve({\n    ...getExtensions(tsNodeService.config),\n    preferTsExts: tsNodeService.options.preferTsExts,\n  });\n\n  // The hooks API changed in node version X so we need to check for backwards compatibility.\n  // TODO: When the new API is backported to v12, v14, v16, update these version checks accordingly.\n  const newHooksAPI =\n    versionGteLt(process.versions.node, '17.0.0') ||\n    versionGteLt(process.versions.node, '16.999.999', '17.0.0') ||\n    versionGteLt(process.versions.node, '14.999.999', '15.0.0') ||\n    versionGteLt(process.versions.node, '12.999.999', '13.0.0');\n\n  // Explicit return type to avoid TS's non-ideal inferred type\n  const hooksAPI: {\n    resolve: typeof resolve;\n    getFormat: typeof getFormat | undefined;\n    transformSource: typeof transformSource | undefined;\n    load: typeof load | undefined;\n  } = newHooksAPI\n    ? { resolve, load, getFormat: undefined, transformSource: undefined }\n    : { resolve, getFormat, transformSource, load: undefined };\n  return hooksAPI;\n\n  function isFileUrlOrNodeStyleSpecifier(parsed: UrlWithStringQuery) {\n    // We only understand file:// URLs, but in node, the specifier can be a node-style `./foo` or `foo`\n    const { protocol } = parsed;\n    return protocol === null || protocol === 'file:';\n  }\n\n  async function resolve(\n    specifier: string,\n    context: { parentURL: string },\n    defaultResolve: typeof resolve\n  ): Promise<{ url: string }> {\n    const defer = async () => {\n      const r = await defaultResolve(specifier, context, defaultResolve);\n      return r;\n    };\n\n    const parsed = parseUrl(specifier);\n    const { pathname, protocol, hostname } = parsed;\n\n    if (!isFileUrlOrNodeStyleSpecifier(parsed)) {\n      return defer();\n    }\n\n    if (protocol !== null && protocol !== 'file:') {\n      return defer();\n    }\n\n    // Malformed file:// URL?  We should always see `null` or `''`\n    if (hostname) {\n      // TODO file://./foo sets `hostname` to `'.'`.  Perhaps we should special-case this.\n      return defer();\n    }\n\n    // pathname is the path to be resolved\n\n    return nodeResolveImplementation.defaultResolve(\n      specifier,\n      context,\n      defaultResolve\n    );\n  }\n\n  // `load` from new loader hook API (See description at the top of this file)\n  async function load(\n    url: string,\n    context: { format: Format | null | undefined },\n    defaultLoad: typeof load\n  ): Promise<{ format: Format; source: string | Buffer | undefined }> {\n    // If we get a format hint from resolve() on the context then use it\n    // otherwise call the old getFormat() hook using node's old built-in defaultGetFormat() that ships with ts-node\n    const format =\n      context.format ??\n      (await getFormat(url, context, defaultGetFormat)).format;\n\n    let source = undefined;\n    if (format !== 'builtin' && format !== 'commonjs') {\n      // Call the new defaultLoad() to get the source\n      const { source: rawSource } = await defaultLoad(\n        url,\n        { format },\n        defaultLoad\n      );\n\n      if (rawSource === undefined || rawSource === null) {\n        throw new Error(\n          `Failed to load raw source: Format was '${format}' and url was '${url}''.`\n        );\n      }\n\n      // Emulate node's built-in old defaultTransformSource() so we can re-use the old transformSource() hook\n      const defaultTransformSource: typeof transformSource = async (\n        source,\n        _context,\n        _defaultTransformSource\n      ) => ({ source });\n\n      // Call the old hook\n      const { source: transformedSource } = await transformSource(\n        rawSource,\n        { url, format },\n        defaultTransformSource\n      );\n      source = transformedSource;\n    }\n\n    return { format, source };\n  }\n\n  type Format = 'builtin' | 'commonjs' | 'dynamic' | 'json' | 'module' | 'wasm';\n  async function getFormat(\n    url: string,\n    context: {},\n    defaultGetFormat: typeof getFormat\n  ): Promise<{ format: Format }> {\n    const defer = (overrideUrl: string = url) =>\n      defaultGetFormat(overrideUrl, context, defaultGetFormat);\n\n    const parsed = parseUrl(url);\n\n    if (!isFileUrlOrNodeStyleSpecifier(parsed)) {\n      return defer();\n    }\n\n    const { pathname } = parsed;\n    assert(\n      pathname !== null,\n      'ESM getFormat() hook: URL should never have null pathname'\n    );\n\n    const nativePath = fileURLToPath(url);\n\n    // If file has .ts, .tsx, or .jsx extension, then ask node how it would treat this file if it were .js\n    const ext = extname(nativePath);\n    let nodeSays: { format: Format };\n    if (ext !== '.js' && !tsNodeService.ignored(nativePath)) {\n      nodeSays = await defer(formatUrl(pathToFileURL(nativePath + '.js')));\n    } else {\n      nodeSays = await defer();\n    }\n    // For files compiled by ts-node that node believes are either CJS or ESM, check if we should override that classification\n    if (\n      !tsNodeService.ignored(nativePath) &&\n      (nodeSays.format === 'commonjs' || nodeSays.format === 'module')\n    ) {\n      const { moduleType } = tsNodeService.moduleTypeClassifier.classifyModule(\n        normalizeSlashes(nativePath)\n      );\n      if (moduleType === 'cjs') {\n        return { format: 'commonjs' };\n      } else if (moduleType === 'esm') {\n        return { format: 'module' };\n      }\n    }\n    return nodeSays;\n  }\n\n  async function transformSource(\n    source: string | Buffer,\n    context: { url: string; format: Format },\n    defaultTransformSource: typeof transformSource\n  ): Promise<{ source: string | Buffer }> {\n    if (source === null || source === undefined) {\n      throw new Error('No source');\n    }\n\n    const defer = () =>\n      defaultTransformSource(source, context, defaultTransformSource);\n\n    const sourceAsString =\n      typeof source === 'string' ? source : source.toString('utf8');\n\n    const { url } = context;\n    const parsed = parseUrl(url);\n\n    if (!isFileUrlOrNodeStyleSpecifier(parsed)) {\n      return defer();\n    }\n    const nativePath = fileURLToPath(url);\n\n    if (tsNodeService.ignored(nativePath)) {\n      return defer();\n    }\n\n    const emittedJs = tsNodeService.compile(sourceAsString, nativePath);\n\n    return { source: emittedJs };\n  }\n}\n"]}
{"version":3,"file":"Trace.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/helpers/Trace.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport type * as CPUProfile from '../../cpu_profile/cpu_profile.js';\nimport * as Types from '../types/types.js';\n\ntype MatchedPairType<T extends Types.TraceEvents.TraceEventPairableAsync> = Types.TraceEvents.SyntheticEventPair<T>;\nexport function stackTraceForEvent(event: Types.TraceEvents.TraceEventData): Types.TraceEvents.TraceEventCallFrame[]|\n    null {\n  if (Types.TraceEvents.isSyntheticInvalidation(event)) {\n    return event.stackTrace || null;\n  }\n  if (event.args?.data?.stackTrace) {\n    return event.args.data.stackTrace;\n  }\n  if (Types.TraceEvents.isTraceEventUpdateLayoutTree(event)) {\n    return event.args.beginData?.stackTrace || null;\n  }\n  return null;\n}\n\nexport function extractOriginFromTrace(firstNavigationURL: string): string|null {\n  const url = new URL(firstNavigationURL);\n  if (url) {\n    // We do this to save some space in the toolbar - seeing the `www` is less\n    // useful than seeing `foo.com` if it's truncated at narrow widths\n    if (url.host.startsWith('www.')) {\n      return url.host.slice(4);\n    }\n    return url.host;\n  }\n  return null;\n}\n\nexport type EventsInThread<T extends Types.TraceEvents.TraceEventData> = Map<Types.TraceEvents.ThreadID, T[]>;\n// Each thread contains events. Events indicate the thread and process IDs, which are\n// used to store the event in the correct process thread entry below.\nexport function addEventToProcessThread<T extends Types.TraceEvents.TraceEventData>(\n    event: T,\n    eventsInProcessThread: Map<Types.TraceEvents.ProcessID, EventsInThread<T>>,\n    ): void {\n  const {tid, pid} = event;\n  let eventsInThread = eventsInProcessThread.get(pid);\n  if (!eventsInThread) {\n    eventsInThread = new Map<Types.TraceEvents.ThreadID, T[]>();\n  }\n\n  let events = eventsInThread.get(tid);\n  if (!events) {\n    events = [];\n  }\n\n  events.push(event);\n  eventsInThread.set(event.tid, events);\n  eventsInProcessThread.set(event.pid, eventsInThread);\n}\n\ntype TimeSpan = {\n  ts: Types.Timing.MicroSeconds,\n  dur?: Types.Timing.MicroSeconds,\n};\nfunction eventTimeComparator(a: TimeSpan, b: TimeSpan): -1|0|1 {\n  const aBeginTime = a.ts;\n  const bBeginTime = b.ts;\n  if (aBeginTime < bBeginTime) {\n    return -1;\n  }\n  if (aBeginTime > bBeginTime) {\n    return 1;\n  }\n  const aDuration = a.dur ?? 0;\n  const bDuration = b.dur ?? 0;\n  const aEndTime = aBeginTime + aDuration;\n  const bEndTime = bBeginTime + bDuration;\n  if (aEndTime > bEndTime) {\n    return -1;\n  }\n  if (aEndTime < bEndTime) {\n    return 1;\n  }\n  return 0;\n}\n/**\n * Sorts all the events in place, in order, by their start time. If they have\n * the same start time, orders them by longest first.\n */\nexport function sortTraceEventsInPlace(events: {ts: Types.Timing.MicroSeconds, dur?: Types.Timing.MicroSeconds}[]):\n    void {\n  events.sort(eventTimeComparator);\n}\n\n/**\n * Returns an array of ordered events that results after merging the two\n * ordered input arrays.\n */\nexport function\nmergeEventsInOrder<T1 extends Types.TraceEvents.TraceEventData, T2 extends Types.TraceEvents.TraceEventData>(\n    eventsArray1: readonly T1[], eventsArray2: readonly T2[]): (T1|T2)[] {\n  const result = [];\n  let i = 0;\n  let j = 0;\n  while (i < eventsArray1.length && j < eventsArray2.length) {\n    const event1 = eventsArray1[i];\n    const event2 = eventsArray2[j];\n    const compareValue = eventTimeComparator(event1, event2);\n    if (compareValue <= 0) {\n      result.push(event1);\n      i++;\n    }\n    if (compareValue === 1) {\n      result.push(event2);\n      j++;\n    }\n  }\n  while (i < eventsArray1.length) {\n    result.push(eventsArray1[i++]);\n  }\n  while (j < eventsArray2.length) {\n    result.push(eventsArray2[j++]);\n  }\n  return result;\n}\n\nexport function getNavigationForTraceEvent(\n    event: Types.TraceEvents.TraceEventData,\n    eventFrameId: string,\n    navigationsByFrameId: Map<string, Types.TraceEvents.TraceEventNavigationStart[]>,\n    ): Types.TraceEvents.TraceEventNavigationStart|null {\n  const navigations = navigationsByFrameId.get(eventFrameId);\n  if (!navigations || eventFrameId === '') {\n    // This event's navigation has been filtered out by the meta handler as a noise event\n    // or contains an empty frameId.\n    return null;\n  }\n\n  const eventNavigationIndex =\n      Platform.ArrayUtilities.nearestIndexFromEnd(navigations, navigation => navigation.ts <= event.ts);\n\n  if (eventNavigationIndex === null) {\n    // This event's navigation has been filtered out by the meta handler as a noise event.\n    return null;\n  }\n  return navigations[eventNavigationIndex];\n}\n\nexport function extractId(event: Types.TraceEvents.TraceEventPairableAsync|\n                          MatchedPairType<Types.TraceEvents.TraceEventPairableAsync>): string|undefined {\n  return event.id ?? event.id2?.global ?? event.id2?.local;\n}\n\nexport function activeURLForFrameAtTime(\n    frameId: string, time: Types.Timing.MicroSeconds,\n    rendererProcessesByFrame:\n        Map<string,\n            Map<Types.TraceEvents.ProcessID,\n                {frame: Types.TraceEvents.TraceFrame, window: Types.Timing.TraceWindowMicroSeconds}[]>>): string|null {\n  const processData = rendererProcessesByFrame.get(frameId);\n  if (!processData) {\n    return null;\n  }\n  for (const processes of processData.values()) {\n    for (const processInfo of processes) {\n      if (processInfo.window.min > time || processInfo.window.max < time) {\n        continue;\n      }\n      return processInfo.frame.url;\n    }\n  }\n  return null;\n}\n\nexport function makeProfileCall(\n    node: CPUProfile.ProfileTreeModel.ProfileNode, ts: Types.Timing.MicroSeconds, pid: Types.TraceEvents.ProcessID,\n    tid: Types.TraceEvents.ThreadID): Types.TraceEvents.SyntheticProfileCall {\n  return {\n    cat: '',\n    name: 'ProfileCall',\n    nodeId: node.id,\n    args: {},\n    ph: Types.TraceEvents.Phase.COMPLETE,\n    pid,\n    tid,\n    ts,\n    dur: Types.Timing.MicroSeconds(0),\n    selfTime: Types.Timing.MicroSeconds(0),\n    callFrame: node.callFrame,\n  };\n}\n\nexport function makeSyntheticTraceEntry(\n    name: string, ts: Types.Timing.MicroSeconds, pid: Types.TraceEvents.ProcessID,\n    tid: Types.TraceEvents.ThreadID): Types.TraceEvents.SyntheticTraceEntry {\n  return {\n    cat: '',\n    name,\n    args: {},\n    ph: Types.TraceEvents.Phase.COMPLETE,\n    pid,\n    tid,\n    ts,\n    dur: Types.Timing.MicroSeconds(0),\n    selfTime: Types.Timing.MicroSeconds(0),\n  };\n}\n\nexport function matchBeginningAndEndEvents(unpairedEvents: Types.TraceEvents.TraceEventPairableAsync[]): Map<string, {\n  begin: Types.TraceEvents.TraceEventPairableAsyncBegin | null,\n  end: Types.TraceEvents.TraceEventPairableAsyncEnd | null,\n}> {\n  // map to store begin and end of the event\n  const matchedPairs: Map<string, {\n    begin: Types.TraceEvents.TraceEventPairableAsyncBegin | null,\n    end: Types.TraceEvents.TraceEventPairableAsyncEnd | null,\n  }> = new Map();\n\n  // looking for start and end\n  for (const event of unpairedEvents) {\n    const syntheticId = getSyntheticId(event);\n    if (syntheticId === undefined) {\n      continue;\n    }\n    // Create a synthetic id to prevent collisions across categories.\n    // Console timings can be dispatched with the same id, so use the\n    // event name as well to generate unique ids.\n    const otherEventsWithID = Platform.MapUtilities.getWithDefault(matchedPairs, syntheticId, () => {\n      return {begin: null, end: null};\n    });\n\n    const isStartEvent = event.ph === Types.TraceEvents.Phase.ASYNC_NESTABLE_START;\n    const isEndEvent = event.ph === Types.TraceEvents.Phase.ASYNC_NESTABLE_END;\n\n    if (isStartEvent) {\n      otherEventsWithID.begin = event as Types.TraceEvents.TraceEventPairableAsyncBegin;\n    } else if (isEndEvent) {\n      otherEventsWithID.end = event as Types.TraceEvents.TraceEventPairableAsyncEnd;\n    }\n  }\n\n  return matchedPairs;\n}\n\nfunction getSyntheticId(event: Types.TraceEvents.TraceEventPairableAsync): string|undefined {\n  const id = extractId(event);\n  return id && `${event.cat}:${id}:${event.name}`;\n}\n\nexport function createSortedSyntheticEvents<T extends Types.TraceEvents.TraceEventPairableAsync>(\n    matchedPairs: Map<string, {\n      begin: Types.TraceEvents.TraceEventPairableAsyncBegin | null,\n      end: Types.TraceEvents.TraceEventPairableAsyncEnd | null,\n    }>,\n    syntheticEventCallback?: (syntheticEvent: MatchedPairType<T>) => void,\n    ): MatchedPairType<T>[] {\n  const syntheticEvents: MatchedPairType<T>[] = [];\n  for (const [id, eventsPair] of matchedPairs.entries()) {\n    const beginEvent = eventsPair.begin;\n    const endEvent = eventsPair.end;\n    if (!beginEvent || !endEvent) {\n      // This should never happen, the backend only creates the events once it\n      // has them both, so we should never get into this state.\n      // If we do, something is very wrong, so let's just drop that problematic event.\n      continue;\n    }\n    const pair = {beginEvent, endEvent};\n    function eventsArePairable(data: {\n      beginEvent: Types.TraceEvents.TraceEventPairableAsyncBegin,\n      endEvent: Types.TraceEvents.TraceEventPairableAsyncEnd,\n    }): data is MatchedPairType<T>['args']['data'] {\n      return Boolean(getSyntheticId(data.beginEvent)) &&\n          getSyntheticId(data.beginEvent) === getSyntheticId(data.endEvent);\n    }\n    if (!eventsArePairable(pair)) {\n      continue;\n    }\n    const event: MatchedPairType<T> = {\n      cat: endEvent.cat,\n      ph: endEvent.ph,\n      pid: endEvent.pid,\n      tid: endEvent.tid,\n      id,\n      // Both events have the same name, so it doesn't matter which we pick to\n      // use as the description\n      name: beginEvent.name,\n      dur: Types.Timing.MicroSeconds(endEvent.ts - beginEvent.ts),\n      ts: beginEvent.ts,\n      args: {\n        data: pair,\n      },\n    };\n\n    if (event.dur < 0) {\n      // We have seen in the backend that sometimes animation events get\n      // generated with multiple begin entries, or multiple end entries, and this\n      // can cause invalid data on the performance panel, so we drop them.\n      // crbug.com/1472375\n      continue;\n    }\n    syntheticEventCallback?.(event);\n    syntheticEvents.push(event);\n  }\n  return syntheticEvents.sort((a, b) => a.ts - b.ts);\n}\n\nexport function createMatchedSortedSyntheticEvents<T extends Types.TraceEvents.TraceEventPairableAsync>(\n    unpairedAsyncEvents: T[],\n    syntheticEventCallback?: (syntheticEvent: MatchedPairType<T>) => void): MatchedPairType<T>[] {\n  const matchedPairs = matchBeginningAndEndEvents(unpairedAsyncEvents);\n  const syntheticEvents = createSortedSyntheticEvents<T>(matchedPairs, syntheticEventCallback);\n  return syntheticEvents;\n}\n"]}
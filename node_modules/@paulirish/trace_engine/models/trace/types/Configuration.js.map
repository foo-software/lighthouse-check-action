{"version":3,"file":"Configuration.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/types/Configuration.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;AA4B7B,MAAM,CAAC,MAAM,OAAO,GAAkB;IACpC,QAAQ,EAAE,EAAE;IACZ,WAAW,EAAE;QACX,0BAA0B,EAAE,KAAK;QACjC,qBAAqB,EAAE,KAAK;KAC7B;IACD,UAAU,EAAE;QAEV;;;;;;;WAOG;QACH,cAAc,EAAE,MAAM;QACtB,aAAa,EAAE,CAAC;KACjB;CACF,CAAC;AAEF;;;;;;;GAOG;AACH,MAAM,UAAU,gBAAgB,CAAC,MAAqB;IACpD,OAAO;QACL,qCAAqC,MAAM,CAAC,WAAW,CAAC,qBAAqB,EAAE;QAC/E,0CAA0C,MAAM,CAAC,WAAW,CAAC,0BAA0B,EAAE;KAC1F,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AACd,CAAC","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nexport type Configuration = Readonly<{\n  settings: {\n      // Currently empty but defining here as we will migrate more settings into this.\n  },\n  experiments: {\n    /**\n     * Include V8 RCS in the timeline\n     */\n    timelineV8RuntimeCallStats: boolean,\n    /**\n     * Show all events: disable the default filtering which hides and excludes some events.\n     */\n    timelineShowAllEvents: boolean,\n  },\n  processing: {\n    /**\n     * How long the processor should pause between event chunks.\n     */\n    pauseDuration: number,\n    /**\n     * How many events should be processed before yielding to the main thread for a pause.\n     */\n    eventsPerChunk: number,\n  },\n}>;\n\nexport const DEFAULT: Configuration = {\n  settings: {},\n  experiments: {\n    timelineV8RuntimeCallStats: false,\n    timelineShowAllEvents: false,\n  },\n  processing: {\n\n    /**\n     * We want to yield regularly to maintain responsiveness. If we yield too often, we're wasting idle time.\n     * We could do this by checking `performance.now()` regularly, but it's an expensive call in such a hot loop.\n     * `eventsPerChunk` is an approximated proxy metric.\n     * But how big a chunk? We're aiming for long tasks that are no smaller than 100ms and not bigger than 200ms.\n     * It's CPU dependent, so it should be calibrated on oldish hardware.\n     * Illustration of a previous change to `eventsPerChunk`: https://imgur.com/wzp8BnR\n     */\n    eventsPerChunk: 50_000,\n    pauseDuration: 0,\n  },\n};\n\n/**\n * Generates a key that can be used to represent this config in a cache. This is\n * used mainly in tests, where we want to avoid re-parsing a file if we have\n * already processed it with the same configuration. This cache key purposefully\n * does not include all settings in the configuration; the processing settings\n * do not impact the actual resulting data. Only new flags in the config that\n * alter parsing should be added to this cache key.\n */\nexport function configToCacheKey(config: Configuration): string {\n  return [\n    `experiments.timelineShowAllEvents:${config.experiments.timelineShowAllEvents}`,\n    `experiments.timelineV8RuntimeCallStats:${config.experiments.timelineV8RuntimeCallStats}`,\n  ].join('-');\n}\n"]}